{"version":3,"file":"953.bundle.290af684a367cad58652.js","mappings":"ucAgBA,MAAM,WAAEA,GAAeC,EAAAA,GAEjBC,EACJ,uCAEIC,EAAyB,cAE/B,SAASC,EAA0BC,GACjC,MAAM,SACJC,EAAQ,WACRC,EAAU,YACVC,EAAW,cACXC,EAAa,cACbC,EAAa,gBACbC,EAAe,iBACfC,GACEP,GAEE,kBACJQ,EAAiB,2BACjBC,EAA0B,mBAC1BC,GACEJ,EAAgBK,SAGpB,GAAIR,EAAYS,OAAS,EACvB,MAAM,IAAIC,MAAM,qDAGlB,MAAMC,EAAeX,EAAY,IAE1BY,EAAcC,IAAuBC,EAAAA,EAAAA,OACrCC,EAAqBC,IAAqBC,EAAAA,EAAAA,OAC1CC,EAAqBC,IAA0BC,EAAAA,EAAAA,UAAS,IACxDC,EAAkBC,IAAuBF,EAAAA,EAAAA,UAAS,IAClDG,EAA2BC,IAAgCJ,EAAAA,EAAAA,UAChE,OAGAK,EACAC,IACEN,EAAAA,EAAAA,UAAS,OACNO,EAAYC,IAAiBR,EAAAA,EAAAA,UAAST,EAAagB,aACnDE,EAASC,IAAcV,EAAAA,EAAAA,UAAS,OACjC,UAAEW,EAAS,oBAAEC,GAAwBpB,EAG3C,IAAIqB,EACAC,EAMJ,GAJwC9B,EAAiB+B,uBAAuBC,SAC9E1C,GAGmC,CACnC,MAAM2C,EAAgBjC,EAAiBkC,eACrC,iFAGIC,GAAUC,EAAAA,EAAAA,YAAWH,EAAcI,SACzCR,EAAsBM,IAAU,GAChCL,EAA+BK,IAAU,EAC3C,CACKL,IAEHD,EAAsB,KACtBC,EAA+B,CAACQ,EAAW,KAA8B,IAA9B,sBAAEC,GAAuB,EAClEpC,EAAmBqC,oBACnB,MAAM,mBAAEC,IAAuBC,EAAAA,EAAAA,GAC7B,CAAE3C,kBAAiBC,oBACnBuC,GAEI3C,EAAcK,EAAkB0C,wBACpCF,EAAmB,IAEjB7C,EAAYS,QACdI,EAAoBmC,0BAA0B,CAC5C/C,cAAe+B,EACfiB,uBAAwB,CAACjD,EAAY,GAAG2C,wBAE5C,GASJ,MAAMO,GAAyBC,EAAAA,EAAAA,cAC7BjC,IACE,MAAM,aAAEkC,GAAiBzC,GAEzB0C,EAAAA,EAAAA,IACExB,EACAuB,EAAaE,KAAIC,GAAeA,EAAYC,2BAC5CtC,EACD,GAEH,CAACW,EAASX,EAAqBP,IAS3B8C,EAAmBC,IACvB5B,EAAW4B,EAAIC,OAAO9B,QAAQ,EAG1B+B,GAAiBT,EAAAA,EAAAA,cACrBU,IACE,MAAM,iBACJC,EAAgB,sBAChBnB,EAAqB,aACrBoB,GACEpD,EAECmD,GAAqBnB,IAItBoB,GAAgBA,EAAatD,OAAS,GAGxCuD,QAAQC,KACN,sEA2RVC,eACEC,EACAjD,EACAb,GAEA,MAAM,aAAE+C,GAAiBe,EACnBZ,EAAcH,EAAalC,IAE3B,sBAAEyB,GAA0BY,EAE5Ba,EAAuB/D,EAAkBgE,mBAC7C1B,GAGI2B,EAASF,EAAqBG,OAAO,GACrC9C,EAA+B,CACnC+C,UAAWF,EAAOE,UAClBC,YAAaH,EAAOG,YACpBC,WAAYJ,EAAOI,WACnBC,WAAYL,EAAOK,WACnBC,eAAgBN,EAAOM,eACvBC,UAAWP,EAAOO,UAClBC,kBAAmBR,EAAOQ,kBAC1BC,kBAAmBT,EAAOS,kBAC1BC,aAAcV,EAAOU,aACrBC,sBAAuBX,EAAOW,sBAC9BC,qBAAsBZ,EAAOY,sBAG/B,MAAO,CAAEzD,+BAA8B2C,uBACzC,CArTMe,CACExE,EACAkD,EACAxD,GACA+E,MAAK,IAA4D,IAA3D,qBAAEhB,EAAoB,6BAAE3C,GAA8B,EAK5D,GAJAN,EAAuB0C,GACvBrC,EAA6B4C,GAC7B1C,EAAgCD,GAG9B2C,EAAqBzB,wBACrBpB,GAA2BoB,sBAC3B,CACA,MAAM,aAAES,GAAiBzC,EAMnB0E,EAAe/E,EAA2BgF,uBAC9CrF,GAGIsF,EAAajF,EAA2BkF,uBAC5CH,EAAaI,iBAKTC,EAFWH,EAAWI,cAEEC,QAC5BxC,EAAaS,GAAwBgC,UAGjB,IAAlBH,GACFH,EAAWO,gBAAgBJ,EAE/B,KACA,GAEJ,CAAC3F,EAAYY,EAAcY,EAA2BtB,IAGlDuF,GAAyBrC,EAAAA,EAAAA,cAAY,KACzC,IAAK5B,EACH,OAAO,KAGT,MAAQwE,UAAWC,GAAc5F,EAAiBkC,eAChD,2DAGI,aAAEc,GAAiBzC,EACnB4C,EAAcH,EAAalC,GAEjC,IAAKqC,EACH,OAAO,KAGT,MAAM0C,EAAoB1E,EAA0BgD,OAAO2B,WACzDC,GAASA,EAAMN,UAAYtC,EAAYsC,UAGzC,OACE,gBAACG,EAAS,KACJnG,EAAK,CAGTG,YAAa,CAACuB,GACd6E,gBAAiB,CACfC,YAAc,GAAE1G,KAElB8D,iBAAkBA,EAClBwC,kBAAmBA,IACR,GAEd,CAAC1E,EAA2BtB,EAAeiB,IAExCoF,GAAsBnD,EAAAA,EAAAA,cAC1BoD,IACE,IAAI1C,EAAyB3C,EAEX,UAAdqF,GACF1C,IAEIA,GAA0BxC,IAC5BwC,EAAyB,KAG3BA,IAEIA,EAAyB,IAC3BA,EAAyBxC,EAAmB,IAIhD6B,EAAuBW,GACvBD,EAAeC,EAAuB,GAExC,CACE3C,EACAG,EACAuC,EACAV,KAOJsD,EAAAA,EAAAA,YAAU,KACR,MAAMC,EAAmCpG,EAAkBqG,UACzDrG,EAAkBsG,OAAOC,sBACzB,IAAgC,IAA/B,uBAAE3D,GAAwB,EACzB,MAAM4D,EAAiB9E,EAAUC,GAE/BiB,EAAuBb,SAASyE,EAAelE,wBAE/C9B,EAAoBmC,0BAA0B,CAC5C/C,cAAe+B,EACfiB,uBAAwB,IAE5B,IAIJ,MAAO,KACLwD,EAAiCK,aAAa,CAC/C,GACA,KASHN,EAAAA,EAAAA,YAAU,KACH7F,EAAaoG,UAChBpG,EAAaqG,OAEfpF,EAAcjB,EAAagB,YAE3B,MAAMsF,EAAkBtG,EAAayC,aAAa3C,OAClDa,EAAoB2F,EAAgB,GACnC,CAACtG,KAMJ6F,EAAAA,EAAAA,YAAU,KACH3E,GAAYlB,EAAaoG,UAG9B7D,EAAuBhC,EAAoB,GAC1C,CAACA,EAAqBW,EAASqB,EAAwBvC,IAM1D,IAAIuG,EAAWjF,GAAqBQ,SAAS0E,eAAe1G,OAAS,GACrE+F,EAAAA,EAAAA,YAAU,KACRU,EAAWjF,GAAqBQ,SAAS0E,eAAe1G,OAAS,CAAC,GACjE,CAACwB,KAMJuE,EAAAA,EAAAA,YAAU,KACR5C,EAAe1C,EAAoB,GAClC,CAACnB,EAAYY,IAGhB,IAAIyG,EAAoB,KAExB,IAAK7F,IAA8BE,EACjC,OAAO,KAGL3B,GAAYA,EAASW,SACvB2G,EAAoBtH,EAASwD,KAAI,CAAC+D,EAAOC,IAErCD,GACAE,EAAAA,aAAmBF,EAAO,CACxBpH,gBACAuH,IAAKF,OAMb,MAAM,UACJ9C,EAAS,YACTC,EAAW,WACXC,EAAU,WACVC,EAAU,eACVC,EAAc,sBACdK,GAAqB,UACrBJ,GAAS,kBACTC,GAAiB,qBACjBI,GAAoB,aACpBF,IACEvD,EAGJ,OACE,gCACE,gBAAC,KAAiB,CAChBgG,cAAe/D,IACbA,EAAIgE,kBACJhE,EAAIiE,gBAAgB,EAEtBC,cAAetB,EACfuB,mBAAoB,IA+F5B,SAA6B,GAM1B,IAN0B,aAC3BlH,EAAY,cACZV,EAAa,eACb6H,EAAc,SACdZ,EAAQ,6BACRhF,GACD,EACC,MAAM6F,EAAgB,KACpB7F,EAA6B,aAAc,CACzCS,sBAAuBhC,EAAagC,sBACpC1C,iBACA,GAGE,EAAE+H,IAAMC,EAAAA,EAAAA,IAAe,UACvBC,EAAUF,EAAE,QAKZG,EACJL,IAAmBZ,EAAW,EAAIY,GAAkBZ,EAAW,EAAI,EACrE,IAAIkB,EAAiB,KACjBC,EAAa,KAEjB,OAAQF,GACN,KAAK,EACHE,EAAa,IAAM,gBAAC,KAAI,CAACC,KAAK,iBAE9BF,EAAiB,IACf,2BAAK,2CAEH,2BAAM,0BAIV,MACF,KAAK,EACHC,EAAa,IAAM,gBAAC,KAAI,CAACC,KAAK,kBAE9BF,EAAiB,IACf,2BAAK,gDAEH,2BAAM,2CAEN,2BAAM,qBAIV,MACF,KAAK,EACHC,EAAa,IAAM,gBAAC,KAAI,CAACC,KAAK,qBAE9BF,EAAiB,IACf,2BAAO,SAAQF,8BAIrB,MAAMK,EAAa,IACjB,uBAAKC,UAAU,wDACb,uBAAKA,UAAU,+EACb,gBAACH,EAAU,MACX,wBAAMG,UAAU,QAAO,OAEd,IAAVL,GACC,uBACEK,UAAU,6FAEVC,UAAWV,GAEVG,IAMT,OACE,gCACGE,GACC,gBAAC,IAAO,CAACM,QAAS,gBAACN,EAAc,MAAKO,SAAS,eAC7C,gBAACJ,EAAU,QAGbH,GAAkB,gBAACG,EAAU,MAGrC,CApLUK,CAAoB,CAClBjI,eACAV,gBACA4I,WAAW,EACXf,eAAgBnH,EAAamH,eAC7BZ,WACAhF,iCAGJ4G,UAAW,CACTC,MAAO7I,EACP8I,eAAe,EACfC,UAAWzJ,EAAWqF,IACtBqE,kBAAmBpE,IAAqB,GACxCqE,mBAAoB,CAClBC,YAAa3E,EACT4E,EAAAA,GAAAA,MAAAA,SAAoB5E,EAAY6E,YAChC,GACJC,WAAY7E,GAAc,GAC1B8E,WAAY7E,GAAc,GAC1B8E,IAAKjF,GAAa,GAClBkF,UAAW9E,EAAkB,GAAEA,EAAe+E,QAAQ,OAAS,GAC/DC,aAC2BC,IAAzB3E,GACK,GAAEA,GAAqByE,QAAQ,OAChC,GACNG,QAAS7E,IAAyB,OAKxC,uBAAKuD,UAAU,wDACZhD,IACD,uBAAKgD,UAAU,mBACZzH,EAAoBd,gBAAkBA,GACrC,gBAAC,KAAY,CACX8J,QAAShJ,EAAoBgJ,QAC7BC,KAAMjJ,EAAoBiJ,KAC1BC,QAASlJ,EAAoBkJ,QAC7BC,SAAUnJ,EAAoBmJ,SAC9BC,eAAgBpJ,EAAoBoJ,kBAIzC/C,GAIT,CAEAxH,EAA0BwK,UAAY,CACpCpK,YAAaqK,IAAAA,QAAkBA,IAAAA,QAC/BpK,cAAeoK,IAAAA,OAAAA,WACftK,WAAYsK,IAAAA,OACZvK,SAAUuK,IAAAA,KACVC,YAAaD,IAAAA,QAGfzK,EAA0B2K,aAAe,CACvCD,YAAa,CAAC,GA2HhB,S","sources":["webpack:///../../../extensions/cornerstone-dicom-sr/src/viewports/OHIFCornerstoneSRViewport.tsx"],"sourcesContent":["import PropTypes from 'prop-types';\r\nimport React, { useCallback, useContext, useEffect, useState } from 'react';\r\nimport { useTranslation } from 'react-i18next';\r\nimport OHIF, { utils } from '@ohif/core';\r\nimport { setTrackingUniqueIdentifiersForElement } from '../tools/modules/dicomSRModule';\r\n\r\nimport {\r\n  Icon,\r\n  Notification,\r\n  Tooltip,\r\n  useViewportDialog,\r\n  useViewportGrid,\r\n  ViewportActionBar,\r\n} from '@ohif/ui';\r\nimport hydrateStructuredReport from '../utils/hydrateStructuredReport';\r\n\r\nconst { formatDate } = utils;\r\n\r\nconst MEASUREMENT_TRACKING_EXTENSION_ID =\r\n  '@ohif/extension-measurement-tracking';\r\n\r\nconst SR_TOOLGROUP_BASE_NAME = 'SRToolGroup';\r\n\r\nfunction OHIFCornerstoneSRViewport(props) {\r\n  const {\r\n    children,\r\n    dataSource,\r\n    displaySets,\r\n    viewportIndex,\r\n    viewportLabel,\r\n    servicesManager,\r\n    extensionManager,\r\n  } = props;\r\n\r\n  const {\r\n    displaySetService,\r\n    cornerstoneViewportService,\r\n    measurementService,\r\n  } = servicesManager.services;\r\n\r\n  // SR viewport will always have a single display set\r\n  if (displaySets.length > 1) {\r\n    throw new Error('SR viewport should only have a single display set');\r\n  }\r\n\r\n  const srDisplaySet = displaySets[0];\r\n\r\n  const [viewportGrid, viewportGridService] = useViewportGrid();\r\n  const [viewportDialogState, viewportDialogApi] = useViewportDialog();\r\n  const [measurementSelected, setMeasurementSelected] = useState(0);\r\n  const [measurementCount, setMeasurementCount] = useState(1);\r\n  const [activeImageDisplaySetData, setActiveImageDisplaySetData] = useState(\r\n    null\r\n  );\r\n  const [\r\n    referencedDisplaySetMetadata,\r\n    setReferencedDisplaySetMetadata,\r\n  ] = useState(null);\r\n  const [isHydrated, setIsHydrated] = useState(srDisplaySet.isHydrated);\r\n  const [element, setElement] = useState(null);\r\n  const { viewports, activeViewportIndex } = viewportGrid;\r\n\r\n  // Optional hook into tracking extension, if present.\r\n  let trackedMeasurements;\r\n  let sendTrackedMeasurementsEvent;\r\n\r\n  const hasMeasurementTrackingExtension = extensionManager.registeredExtensionIds.includes(\r\n    MEASUREMENT_TRACKING_EXTENSION_ID\r\n  );\r\n\r\n  if (hasMeasurementTrackingExtension) {\r\n    const contextModule = extensionManager.getModuleEntry(\r\n      '@ohif/extension-measurement-tracking.contextModule.TrackedMeasurementsContext'\r\n    );\r\n\r\n    const tracked = useContext(contextModule.context);\r\n    trackedMeasurements = tracked?.[0];\r\n    sendTrackedMeasurementsEvent = tracked?.[1];\r\n  }\r\n  if (!sendTrackedMeasurementsEvent) {\r\n    // if no panels from measurement-tracking extension is used, this code will run\r\n    trackedMeasurements = null;\r\n    sendTrackedMeasurementsEvent = (eventName, { displaySetInstanceUID }) => {\r\n      measurementService.clearMeasurements();\r\n      const { SeriesInstanceUIDs } = hydrateStructuredReport(\r\n        { servicesManager, extensionManager },\r\n        displaySetInstanceUID\r\n      );\r\n      const displaySets = displaySetService.getDisplaySetsForSeries(\r\n        SeriesInstanceUIDs[0]\r\n      );\r\n      if (displaySets.length) {\r\n        viewportGridService.setDisplaySetsForViewport({\r\n          viewportIndex: activeViewportIndex,\r\n          displaySetInstanceUIDs: [displaySets[0].displaySetInstanceUID],\r\n        });\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Store the tracking identifiers per viewport in order to be able to\r\n   * show the SR measurements on the referenced image on the correct viewport,\r\n   * when multiple viewports are used.\r\n   */\r\n  const setTrackingIdentifiers = useCallback(\r\n    measurementSelected => {\r\n      const { measurements } = srDisplaySet;\r\n\r\n      setTrackingUniqueIdentifiersForElement(\r\n        element,\r\n        measurements.map(measurement => measurement.TrackingUniqueIdentifier),\r\n        measurementSelected\r\n      );\r\n    },\r\n    [element, measurementSelected, srDisplaySet]\r\n  );\r\n\r\n  /**\r\n   * OnElementEnabled callback which is called after the cornerstoneExtension\r\n   * has enabled the element. Note: we delegate all the image rendering to\r\n   * cornerstoneExtension, so we don't need to do anything here regarding\r\n   * the image rendering, element enabling etc.\r\n   */\r\n  const onElementEnabled = evt => {\r\n    setElement(evt.detail.element);\r\n  };\r\n\r\n  const updateViewport = useCallback(\r\n    newMeasurementSelected => {\r\n      const {\r\n        StudyInstanceUID,\r\n        displaySetInstanceUID,\r\n        sopClassUids,\r\n      } = srDisplaySet;\r\n\r\n      if (!StudyInstanceUID || !displaySetInstanceUID) {\r\n        return;\r\n      }\r\n\r\n      if (sopClassUids && sopClassUids.length > 1) {\r\n        // Todo: what happens if there are multiple SOP Classes? Why we are\r\n        // not throwing an error?\r\n        console.warn(\r\n          'More than one SOPClassUID in the same series is not yet supported.'\r\n        );\r\n      }\r\n\r\n      _getViewportReferencedDisplaySetData(\r\n        srDisplaySet,\r\n        newMeasurementSelected,\r\n        displaySetService\r\n      ).then(({ referencedDisplaySet, referencedDisplaySetMetadata }) => {\r\n        setMeasurementSelected(newMeasurementSelected);\r\n        setActiveImageDisplaySetData(referencedDisplaySet);\r\n        setReferencedDisplaySetMetadata(referencedDisplaySetMetadata);\r\n\r\n        if (\r\n          referencedDisplaySet.displaySetInstanceUID ===\r\n          activeImageDisplaySetData?.displaySetInstanceUID\r\n        ) {\r\n          const { measurements } = srDisplaySet;\r\n\r\n          // it means that we have a new referenced display set, and the\r\n          // imageIdIndex will handle it by updating the viewport, but if they\r\n          // are the same we just need to use measurementService to jump to the\r\n          // new measurement\r\n          const viewportInfo = cornerstoneViewportService.getViewportInfoByIndex(\r\n            viewportIndex\r\n          );\r\n\r\n          const csViewport = cornerstoneViewportService.getCornerstoneViewport(\r\n            viewportInfo.getViewportId()\r\n          );\r\n\r\n          const imageIds = csViewport.getImageIds();\r\n\r\n          const imageIdIndex = imageIds.indexOf(\r\n            measurements[newMeasurementSelected].imageId\r\n          );\r\n\r\n          if (imageIdIndex !== -1) {\r\n            csViewport.setImageIdIndex(imageIdIndex);\r\n          }\r\n        }\r\n      });\r\n    },\r\n    [dataSource, srDisplaySet, activeImageDisplaySetData, viewportIndex]\r\n  );\r\n\r\n  const getCornerstoneViewport = useCallback(() => {\r\n    if (!activeImageDisplaySetData) {\r\n      return null;\r\n    }\r\n\r\n    const { component: Component } = extensionManager.getModuleEntry(\r\n      '@ohif/extension-cornerstone.viewportModule.cornerstone'\r\n    );\r\n\r\n    const { measurements } = srDisplaySet;\r\n    const measurement = measurements[measurementSelected];\r\n\r\n    if (!measurement) {\r\n      return null;\r\n    }\r\n\r\n    const initialImageIndex = activeImageDisplaySetData.images.findIndex(\r\n      image => image.imageId === measurement.imageId\r\n    );\r\n\r\n    return (\r\n      <Component\r\n        {...props}\r\n        // should be passed second since we don't want SR displaySet to\r\n        // override the activeImageDisplaySetData\r\n        displaySets={[activeImageDisplaySetData]}\r\n        viewportOptions={{\r\n          toolGroupId: `${SR_TOOLGROUP_BASE_NAME}`,\r\n        }}\r\n        onElementEnabled={onElementEnabled}\r\n        initialImageIndex={initialImageIndex}\r\n      ></Component>\r\n    );\r\n  }, [activeImageDisplaySetData, viewportIndex, measurementSelected]);\r\n\r\n  const onMeasurementChange = useCallback(\r\n    direction => {\r\n      let newMeasurementSelected = measurementSelected;\r\n\r\n      if (direction === 'right') {\r\n        newMeasurementSelected++;\r\n\r\n        if (newMeasurementSelected >= measurementCount) {\r\n          newMeasurementSelected = 0;\r\n        }\r\n      } else {\r\n        newMeasurementSelected--;\r\n\r\n        if (newMeasurementSelected < 0) {\r\n          newMeasurementSelected = measurementCount - 1;\r\n        }\r\n      }\r\n\r\n      setTrackingIdentifiers(newMeasurementSelected);\r\n      updateViewport(newMeasurementSelected);\r\n    },\r\n    [\r\n      measurementSelected,\r\n      measurementCount,\r\n      updateViewport,\r\n      setTrackingIdentifiers,\r\n    ]\r\n  );\r\n\r\n  /**\r\n   Cleanup the SR viewport when the viewport is destroyed\r\n   */\r\n  useEffect(() => {\r\n    const onDisplaySetsRemovedSubscription = displaySetService.subscribe(\r\n      displaySetService.EVENTS.DISPLAY_SETS_REMOVED,\r\n      ({ displaySetInstanceUIDs }) => {\r\n        const activeViewport = viewports[activeViewportIndex];\r\n        if (\r\n          displaySetInstanceUIDs.includes(activeViewport.displaySetInstanceUID)\r\n        ) {\r\n          viewportGridService.setDisplaySetsForViewport({\r\n            viewportIndex: activeViewportIndex,\r\n            displaySetInstanceUIDs: [],\r\n          });\r\n        }\r\n      }\r\n    );\r\n\r\n    return () => {\r\n      onDisplaySetsRemovedSubscription.unsubscribe();\r\n    };\r\n  }, []);\r\n\r\n  /**\r\n   * Loading the measurements from the SR viewport, which goes through the\r\n   * isHydratable check, the outcome for the isHydrated state here is always FALSE\r\n   * since we don't do the hydration here. Todo: can't we just set it as false? why\r\n   * we are changing the state here? isHydrated is always false at this stage, and\r\n   * if it is hydrated we don't even use the SR viewport.\r\n   */\r\n  useEffect(() => {\r\n    if (!srDisplaySet.isLoaded) {\r\n      srDisplaySet.load();\r\n    }\r\n    setIsHydrated(srDisplaySet.isHydrated);\r\n\r\n    const numMeasurements = srDisplaySet.measurements.length;\r\n    setMeasurementCount(numMeasurements);\r\n  }, [srDisplaySet]);\r\n\r\n  /**\r\n   * Hook to update the tracking identifiers when the selected measurement changes or\r\n   * the element changes\r\n   */\r\n  useEffect(() => {\r\n    if (!element || !srDisplaySet.isLoaded) {\r\n      return;\r\n    }\r\n    setTrackingIdentifiers(measurementSelected);\r\n  }, [measurementSelected, element, setTrackingIdentifiers, srDisplaySet]);\r\n\r\n  /**\r\n   * Todo: what is this, not sure what it does regarding the react aspect,\r\n   * it is updating a local variable? which is not state.\r\n   */\r\n  let isLocked = trackedMeasurements?.context?.trackedSeries?.length > 0;\r\n  useEffect(() => {\r\n    isLocked = trackedMeasurements?.context?.trackedSeries?.length > 0;\r\n  }, [trackedMeasurements]);\r\n\r\n  /**\r\n   * Data fetching for the SR displaySet, which updates the measurements and\r\n   * also gets the referenced image displaySet that SR is based on.\r\n   */\r\n  useEffect(() => {\r\n    updateViewport(measurementSelected);\r\n  }, [dataSource, srDisplaySet]);\r\n\r\n  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n  let childrenWithProps = null;\r\n\r\n  if (!activeImageDisplaySetData || !referencedDisplaySetMetadata) {\r\n    return null;\r\n  }\r\n\r\n  if (children && children.length) {\r\n    childrenWithProps = children.map((child, index) => {\r\n      return (\r\n        child &&\r\n        React.cloneElement(child, {\r\n          viewportIndex,\r\n          key: index,\r\n        })\r\n      );\r\n    });\r\n  }\r\n\r\n  const {\r\n    PatientID,\r\n    PatientName,\r\n    PatientSex,\r\n    PatientAge,\r\n    SliceThickness,\r\n    ManufacturerModelName,\r\n    StudyDate,\r\n    SeriesDescription,\r\n    SpacingBetweenSlices,\r\n    SeriesNumber,\r\n  } = referencedDisplaySetMetadata;\r\n\r\n  // TODO -> disabled double click for now: onDoubleClick={_onDoubleClick}\r\n  return (\r\n    <>\r\n      <ViewportActionBar\r\n        onDoubleClick={evt => {\r\n          evt.stopPropagation();\r\n          evt.preventDefault();\r\n        }}\r\n        onArrowsClick={onMeasurementChange}\r\n        getStatusComponent={() =>\r\n          _getStatusComponent({\r\n            srDisplaySet,\r\n            viewportIndex,\r\n            isTracked: false,\r\n            isRehydratable: srDisplaySet.isRehydratable,\r\n            isLocked,\r\n            sendTrackedMeasurementsEvent,\r\n          })\r\n        }\r\n        studyData={{\r\n          label: viewportLabel,\r\n          useAltStyling: true,\r\n          studyDate: formatDate(StudyDate),\r\n          seriesDescription: SeriesDescription || '',\r\n          patientInformation: {\r\n            patientName: PatientName\r\n              ? OHIF.utils.formatPN(PatientName.Alphabetic)\r\n              : '',\r\n            patientSex: PatientSex || '',\r\n            patientAge: PatientAge || '',\r\n            MRN: PatientID || '',\r\n            thickness: SliceThickness ? `${SliceThickness.toFixed(2)}mm` : '',\r\n            spacing:\r\n              SpacingBetweenSlices !== undefined\r\n                ? `${SpacingBetweenSlices.toFixed(2)}mm`\r\n                : '',\r\n            scanner: ManufacturerModelName || '',\r\n          },\r\n        }}\r\n      />\r\n\r\n      <div className=\"relative flex flex-row w-full h-full overflow-hidden\">\r\n        {getCornerstoneViewport()}\r\n        <div className=\"absolute w-full\">\r\n          {viewportDialogState.viewportIndex === viewportIndex && (\r\n            <Notification\r\n              message={viewportDialogState.message}\r\n              type={viewportDialogState.type}\r\n              actions={viewportDialogState.actions}\r\n              onSubmit={viewportDialogState.onSubmit}\r\n              onOutsideClick={viewportDialogState.onOutsideClick}\r\n            />\r\n          )}\r\n        </div>\r\n        {childrenWithProps}\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n\r\nOHIFCornerstoneSRViewport.propTypes = {\r\n  displaySets: PropTypes.arrayOf(PropTypes.object),\r\n  viewportIndex: PropTypes.number.isRequired,\r\n  dataSource: PropTypes.object,\r\n  children: PropTypes.node,\r\n  customProps: PropTypes.object,\r\n};\r\n\r\nOHIFCornerstoneSRViewport.defaultProps = {\r\n  customProps: {},\r\n};\r\n\r\nasync function _getViewportReferencedDisplaySetData(\r\n  displaySet,\r\n  measurementSelected,\r\n  displaySetService\r\n) {\r\n  const { measurements } = displaySet;\r\n  const measurement = measurements[measurementSelected];\r\n\r\n  const { displaySetInstanceUID } = measurement;\r\n\r\n  const referencedDisplaySet = displaySetService.getDisplaySetByUID(\r\n    displaySetInstanceUID\r\n  );\r\n\r\n  const image0 = referencedDisplaySet.images[0];\r\n  const referencedDisplaySetMetadata = {\r\n    PatientID: image0.PatientID,\r\n    PatientName: image0.PatientName,\r\n    PatientSex: image0.PatientSex,\r\n    PatientAge: image0.PatientAge,\r\n    SliceThickness: image0.SliceThickness,\r\n    StudyDate: image0.StudyDate,\r\n    SeriesDescription: image0.SeriesDescription,\r\n    SeriesInstanceUID: image0.SeriesInstanceUID,\r\n    SeriesNumber: image0.SeriesNumber,\r\n    ManufacturerModelName: image0.ManufacturerModelName,\r\n    SpacingBetweenSlices: image0.SpacingBetweenSlices,\r\n  };\r\n\r\n  return { referencedDisplaySetMetadata, referencedDisplaySet };\r\n}\r\n\r\nfunction _getStatusComponent({\r\n  srDisplaySet,\r\n  viewportIndex,\r\n  isRehydratable,\r\n  isLocked,\r\n  sendTrackedMeasurementsEvent,\r\n}) {\r\n  const handleMouseUp = () => {\r\n    sendTrackedMeasurementsEvent('HYDRATE_SR', {\r\n      displaySetInstanceUID: srDisplaySet.displaySetInstanceUID,\r\n      viewportIndex,\r\n    });\r\n  };\r\n\r\n  const { t } = useTranslation('Common');\r\n  const loadStr = t('LOAD');\r\n\r\n  // 1 - Incompatible\r\n  // 2 - Locked\r\n  // 3 - Rehydratable / Open\r\n  const state =\r\n    isRehydratable && !isLocked ? 3 : isRehydratable && isLocked ? 2 : 1;\r\n  let ToolTipMessage = null;\r\n  let StatusIcon = null;\r\n\r\n  switch (state) {\r\n    case 1:\r\n      StatusIcon = () => <Icon name=\"status-alert\" />;\r\n\r\n      ToolTipMessage = () => (\r\n        <div>\r\n          This structured report is not compatible\r\n          <br />\r\n          with this application.\r\n        </div>\r\n      );\r\n      break;\r\n    case 2:\r\n      StatusIcon = () => <Icon name=\"status-locked\" />;\r\n\r\n      ToolTipMessage = () => (\r\n        <div>\r\n          This structured report is currently read-only\r\n          <br />\r\n          because you are tracking measurements in\r\n          <br />\r\n          another viewport.\r\n        </div>\r\n      );\r\n      break;\r\n    case 3:\r\n      StatusIcon = () => <Icon name=\"status-untracked\" />;\r\n\r\n      ToolTipMessage = () => (\r\n        <div>{`Click ${loadStr} to restore measurements.`}</div>\r\n      );\r\n  }\r\n\r\n  const StatusArea = () => (\r\n    <div className=\"flex h-6 leading-6 cursor-default text-sm text-white\">\r\n      <div className=\"min-w-[45px] flex items-center p-1 rounded-l-xl rounded-r bg-customgray-100\">\r\n        <StatusIcon />\r\n        <span className=\"ml-1\">SR</span>\r\n      </div>\r\n      {state === 3 && (\r\n        <div\r\n          className=\"ml-1 px-1.5 rounded cursor-pointer hover:text-black bg-primary-main hover:bg-primary-light\"\r\n          // Using onMouseUp here because onClick is not working when the viewport is not active and is styled with pointer-events:none\r\n          onMouseUp={handleMouseUp}\r\n        >\r\n          {loadStr}\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n\r\n  return (\r\n    <>\r\n      {ToolTipMessage && (\r\n        <Tooltip content={<ToolTipMessage />} position=\"bottom-left\">\r\n          <StatusArea />\r\n        </Tooltip>\r\n      )}\r\n      {!ToolTipMessage && <StatusArea />}\r\n    </>\r\n  );\r\n}\r\n\r\nexport default OHIFCornerstoneSRViewport;\r\n"],"names":["formatDate","utils","MEASUREMENT_TRACKING_EXTENSION_ID","SR_TOOLGROUP_BASE_NAME","OHIFCornerstoneSRViewport","props","children","dataSource","displaySets","viewportIndex","viewportLabel","servicesManager","extensionManager","displaySetService","cornerstoneViewportService","measurementService","services","length","Error","srDisplaySet","viewportGrid","viewportGridService","useViewportGrid","viewportDialogState","viewportDialogApi","useViewportDialog","measurementSelected","setMeasurementSelected","useState","measurementCount","setMeasurementCount","activeImageDisplaySetData","setActiveImageDisplaySetData","referencedDisplaySetMetadata","setReferencedDisplaySetMetadata","isHydrated","setIsHydrated","element","setElement","viewports","activeViewportIndex","trackedMeasurements","sendTrackedMeasurementsEvent","registeredExtensionIds","includes","contextModule","getModuleEntry","tracked","useContext","context","eventName","displaySetInstanceUID","clearMeasurements","SeriesInstanceUIDs","hydrateStructuredReport","getDisplaySetsForSeries","setDisplaySetsForViewport","displaySetInstanceUIDs","setTrackingIdentifiers","useCallback","measurements","setTrackingUniqueIdentifiersForElement","map","measurement","TrackingUniqueIdentifier","onElementEnabled","evt","detail","updateViewport","newMeasurementSelected","StudyInstanceUID","sopClassUids","console","warn","async","displaySet","referencedDisplaySet","getDisplaySetByUID","image0","images","PatientID","PatientName","PatientSex","PatientAge","SliceThickness","StudyDate","SeriesDescription","SeriesInstanceUID","SeriesNumber","ManufacturerModelName","SpacingBetweenSlices","_getViewportReferencedDisplaySetData","then","viewportInfo","getViewportInfoByIndex","csViewport","getCornerstoneViewport","getViewportId","imageIdIndex","getImageIds","indexOf","imageId","setImageIdIndex","component","Component","initialImageIndex","findIndex","image","viewportOptions","toolGroupId","onMeasurementChange","direction","useEffect","onDisplaySetsRemovedSubscription","subscribe","EVENTS","DISPLAY_SETS_REMOVED","activeViewport","unsubscribe","isLoaded","load","numMeasurements","isLocked","trackedSeries","childrenWithProps","child","index","React","key","onDoubleClick","stopPropagation","preventDefault","onArrowsClick","getStatusComponent","isRehydratable","handleMouseUp","t","useTranslation","loadStr","state","ToolTipMessage","StatusIcon","name","StatusArea","className","onMouseUp","content","position","_getStatusComponent","isTracked","studyData","label","useAltStyling","studyDate","seriesDescription","patientInformation","patientName","OHIF","Alphabetic","patientSex","patientAge","MRN","thickness","toFixed","spacing","undefined","scanner","message","type","actions","onSubmit","onOutsideClick","propTypes","PropTypes","customProps","defaultProps"],"sourceRoot":""}